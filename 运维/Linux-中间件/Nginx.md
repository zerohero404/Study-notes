# 1.1 Nginx 用到的几种概念

## 同步与异步

同步与异步的重点在消息通知的方式上，也就是调用结果的通知方式不同：

- **同步**：当一个同步调用发出去之后，调用者要一直等待调用的结果通知后，才能进行后续的执行。
- **异步**：当一个异步调用发出去后，调用者不必一直等待调用结果的返回。异步调用想要获得结果一般有两种方式：
  1. 主动轮询异步调用的结果
  2. 被调用方通过 callback（回调通知）来通知调用方调用结果

### 实例解释

- **同步**：小明收到快递即将送达的短信，在楼下一直等着。
- **异步**：小明收到快递即将送达的短信，快递到楼下后，小明再下楼去取。小明知道快递到达楼下有两种方式：
  - 不停的打电话给快递小哥，即主动轮询
  - 快递小哥到楼下后，打电话通知小明，然后小明下楼取快递，即回调通知

## 阻塞与非阻塞

阻塞与非阻塞的区别在于进程/线程等待消息时候的行为，也就是在等待消息的时候，当前进程/线程是挂起状态还是非挂起状态：

- **阻塞**：调用发出去后，在消息返回之前，当前进程/线程会被挂起，直到有消息返回，当前进程/线程才会被激活。
- **非阻塞**：调用发出去后，不会阻塞当前进程/线程，而会立即返回。

### 实例解释

- **阻塞取快递**：小明收到快递即将送达消息，什么事都不做，一直专门等快递。
- **非阻塞取快递**：小明收到快递即将送达消息，等快递的时候，还一边敲代码、一边刷微信。

## 四种组合方式

同步与异步，重点在于消息通知的方式；阻塞与非阻塞，重点在于等消息时候的行为，所以有下面四种组合方式：

1. **同步阻塞**：小明收到信息后，啥都不干，等快递。
2. **同步非阻塞**：小明收到信息后，边刷微博，边等着取快递。
3. **异步阻塞**：小明收到信息后，啥都不干，一直等着快递员通知他取快递。
4. **异步非阻塞**：小明收到信息后，边刷微博，边等快递员通知他取快递。

大部分程序的 I/O 模型都是同步阻塞，单个进程每次只在一个文件描述上执行 I/O 操作，每次 I/O 系统调用都会阻塞，直到完成数据传输。传统的服务器采用的就是同步阻塞的多进程模型。一个 server 采用一个进程负责一个 request 的方式，一个进程负责一个 request，直到会话结束。进程数就是并发数，而操作系统支持的进程数是有限的，且进程数越多，调度的开销也越大，因此无法面对高并发。

Nginx 采用了异步非阻塞的方式工作。我们先来了解一下 I/O 多路复用中的 epoll 模型。

## epoll 模型

当连接有 I/O 事件产生的时候，epoll 就会去告诉进程哪个连接有 I/O 事件产生，然后进程去处理这个事件。

**实例解释**：  
小明家楼下有一个收发室，每次有快递到了，门卫就先代收并做了标记；然后再通知小明去取快递。

## 为什么 Nginx 比其他 Web 服务器并发高（Nginx工作原理）

- Nginx 配置 `use epoll` 后，以异步非阻塞方式工作，能够处理百万级的并发连接。
- 处理过程：
  1. 每个 request 进来时，会有一个 worker 进程去处理。
  2. 处理过程中可能会发生阻塞的地方（如向后端服务器转发 request 并等待返回），这个 worker 不会傻等，而是发送完请求后注册一个事件：“如果后端服务器返回了，告诉我一声，我再接着干”。
  3. 此时 worker 去休息，如果再有新的 request 进来，可以很快按这种方式处理。
  4. 一旦后端服务器返回，就触发事件，worker 接手 request 并继续处理。

通过这种快速处理、快速释放请求的方式，Nginx 可以在相同配置下处理更高的并发量。

# 1.2 Nginx 详解

 <img width="726" height="413" alt="Linux：网络服务_41" src="https://github.com/user-attachments/assets/64a6c8e5-124d-4d48-ac1e-f39899cae2c8" />
 
 <img width="913" height="405" alt="Linux：网络服务_42" src="https://github.com/user-attachments/assets/7e877149-c5ba-4f1d-9709-b1c36f277f99" />

 # 1.2 Nginx 工作模式

Nginx 有两种工作模式：**master-worker 模式**和**单进程模式**。

## Master-Worker 模式

在这种模式下，有一个 **master 进程** 和至少一个 **worker 进程**：

- **Master 进程**：
  - 处理系统信号
  - 加载配置
  - 管理 worker 进程（启动、杀死、监控、发送消息/信号等）
- **Worker 进程**：
  - 负责处理具体的业务逻辑
  - 对外提供服务，是真正的服务提供者

### 优点

1. **稳定性高**  
   worker 进程挂掉时，master 进程会立即启动新的 worker 进程，保证服务不中断。
2. **充分利用多核 CPU**  
   配合 Linux 的 CPU 亲和性配置，提升性能。
3. **支持热重启**  
   处理信号、配置重新加载或升级时，可以尽可能少或者不中断服务。

生产环境一般使用此模式。

## 单进程模式

在单进程模式下，Nginx 启动后只有一个进程，所有工作都由该进程负责：

- 优点：
  - 易于调试，可使用 gdb 等工具进行调试。
- 缺点：
  - 不支持平滑升级功能
  - 信号处理可能造成服务终端
  - 进程挂掉后，若无外部监控无法自动重启

一般只在开发阶段和调试阶段使用，生产环境不会采用。

# 1.3 Nginx 配置文件结构

## 配置文件位置

- Nginx 的配置文件位置
**<你安装nginx的路径>/nginx/conf/nginx.conf**

```bash
user XXX XXX;                            
# 程序运行用户和组
worker_processes  1;                     
# 启动进程，指定 nginx 启动的工作进程数量，建议按照 cpu 数目来制定，一般等于 cpu 核心数目
error_log /home/wwwlogs/nginx_error.log crit;
# 全局错误日志
pid        logs/nginx.pid;
# 主进程 PID 保存文件
worker_rlimit_nofile 51200;
# 文件描述符数量
events {
    use epoll;
    # 使用 epoll 模型，对于 2.6 以上的内核，建议使用 epoll 模型以提高性能
    worker_connections  1024;
    # 工作进程的最大了解数量
}

http{
    # 网站优化参数
    server {                                        # 某以网站的具体配置信息
        listen       80;                            # 监听端口
        root html;                                  # 网页根目录
        server_name  localhost;                     # 服务器域名
        index    index.html;                        # 默认加载页面
        access_log  logs/host.access.log  main;     # 访问日志保存位置
        location(.*)\.php${
            # 用正则匹配具体的访问对象
        }
        location{
            # 跳转规则
        }
     }
     sercer{
         # 虚拟主机
     }
}
```


